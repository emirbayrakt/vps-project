services:
    ### â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Database â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    mongo:
        build:
            context: .
            dockerfile: Dockerfile.mongo
        restart: always
        env_file: .env
        command:
            - mongod
            - --bind_ip_all
            - --auth
            - --replSet
            - rs0
            - --keyFile
            - /data/replica.key
            - --quiet
        volumes:
            - mongo-data:/data/db
            - /etc/timezone:/etc/timezone:ro
            - /etc/localtime:/etc/localtime:ro
        networks:
            - backend
        environment:
            TZ: Europe/Berlin
            MONGO_INITDB_ROOT_USERNAME: ${MONGO_INITDB_ROOT_USERNAME}
            MONGO_INITDB_ROOT_PASSWORD: ${MONGO_INITDB_ROOT_PASSWORD}
        healthcheck:
            test: >
                mongosh --quiet -u $${MONGO_INITDB_ROOT_USERNAME}
                -p $${MONGO_INITDB_ROOT_PASSWORD}
                --authenticationDatabase admin
                --eval 'db.runCommand({ ping: 1 })'
            interval: 30s
            timeout: 10s
            retries: 5
            start_period: 30s

    ### â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ rs.initiate thingy â”€â”€â”€â”€â”€

    mongo-init:
        image: mongo:7.0-jammy
        depends_on:
            - mongo
        # run a tiny shell snippet that only calls rs.initiate() if needed
        entrypoint: |
            bash -c '
            # ---------- wait for mongod to answer ----------
            until mongosh --host mongo \
                -u "$$MONGO_INITDB_ROOT_USERNAME" \
                -p "$$MONGO_INITDB_ROOT_PASSWORD" \
                --authenticationDatabase admin \
                --eval "db.adminCommand({ ping: 1 })" >/dev/null 2>&1
            do
                echo "â³ waiting for mongod to accept connectionsâ€¦"
                sleep 2
            done

            echo "ğŸš€ initiating replica setâ€¦"

            # ---------- run rs.initiate() exactly once ----------
            mongosh --host mongo \
                -u "$$MONGO_INITDB_ROOT_USERNAME" \
                -p "$$MONGO_INITDB_ROOT_PASSWORD" \
                --authenticationDatabase admin <<'EOS'
            try {
                rs.initiate({
                _id: "rs0",
                members: [{ _id: 0, host: "mongo:27017" }]
                });
            } catch (e) {
                // if itâ€™s already initialised, just log and exit 0
                print("Replicaâ€‘set init skipped:", e.message);
            }
            quit();
            EOS
            '
        env_file:
            - .env
        networks:
            - backend
        restart: "no"
    ### â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Mongo â†’ automatic dumps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    mongo-backup:
        image: mongo:7.0-jammy # includes mongodump
        depends_on:
            mongo:
                condition: service_healthy # wait until the DB is up
        env_file: .env
        restart: always
        networks:
            - backend
        environment:
            TZ: Europe/Berlin
        volumes:
            - auto-db-backup:/backups
            - /etc/timezone:/etc/timezone:ro
            - /etc/localtime:/etc/localtime:ro
        entrypoint: >
            bash -c '
            set -e
            echo "ğŸ“¦ Mongo backup service started"
            while true; do
                ts=$(date +%Y%m%dT%H%M%S)
                echo "â³  Dumping at $ts â€¦"
                mongodump --uri="mongodb://${MONGO_INITDB_ROOT_USERNAME}:${MONGO_INITDB_ROOT_PASSWORD}@mongo:27017/?authSource=admin&replicaSet=rs0" \
                        --archive=/backups/dump_${ts}.gz --gzip
                echo "âœ…  Dump finished"
                echo "ğŸ§¹  Purging dumps older than 30â€¯days â€¦"
                find /backups -type f -mtime +30 -name "*.gz" -delete
                echo "ğŸ’¤  Sleeping 10â€¯h â€¦"
                sleep 36000   # 10â€¯h = 10Â Ã—Â 60Â Ã—Â 60Â s
            done
            '

    ### â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Message Queue â”€â”€â”€â”€â”€
    rabbitmq:
        build:
            context: .
            dockerfile: Dockerfile.rabbitmq
        restart: always
        env_file: .env
        volumes:
            - /etc/timezone:/etc/timezone:ro
            - /etc/localtime:/etc/localtime:ro
            - rabbitmq-data:/var/lib/rabbitmq
        networks:
            - backend
        environment:
            TZ: Europe/Berlin
            RABBITMQ_DEFAULT_USER: ${RABBITMQ_DEFAULT_USER}
            RABBITMQ_DEFAULT_PASS: ${RABBITMQ_DEFAULT_PASS}
        healthcheck:
            test: ["CMD", "rabbitmq-diagnostics", "ping"]
            interval: 30s
            timeout: 10s
            retries: 5

    ### â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Node API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    api:
        build:
            context: ./node
            dockerfile: Dockerfile.api
        env_file: .env
        environment:
            TZ: Europe/Berlin
            REDIS_HOST: redis
            REDIS_PORT: 6379
            REDIS_PASSWORD: ${REDIS_PASSWORD}
        restart: always
        depends_on:
            redis:
                condition: service_healthy
            mongo:
                condition: service_healthy
            rabbitmq:
                condition: service_healthy
        volumes:
            - public:/app/public # persistent uploads
            - auto-file-backups:/app/auto-file-backups # files backups
            - tmp-files:/app/tmp
            - /etc/timezone:/etc/timezone:ro
            - /etc/localtime:/etc/localtime:ro
        networks:
            - backend
            - frontend
        ports:
            - "3000:3000"
        healthcheck:
            test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
            interval: 30s
            timeout: 5s
            retries: 3
            start_period: 20s

    ### â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Node Worker (single core work)  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    worker:
        build:
            context: ./node
            dockerfile: Dockerfile.worker
        env_file: .env
        environment:
            TZ: Europe/Berlin
            REDIS_HOST: redis
            REDIS_PORT: 6379
            REDIS_PASSWORD: ${REDIS_PASSWORD}
            RABBITMQ_DEFAULT_USER: ${RABBITMQ_DEFAULT_USER}
            RABBITMQ_DEFAULT_PASS: ${RABBITMQ_DEFAULT_PASS}
        restart: always
        depends_on:
            rabbitmq:
                condition: service_healthy
            mongo:
                condition: service_healthy
            redis:
                condition: service_healthy
        volumes:
            - public:/app/public # persistent uploads
            - auto-file-backups:/app/auto-file-backups # files backups
            - tmp-files:/app/tmp
            - /etc/timezone:/etc/timezone:ro
            - /etc/localtime:/etc/localtime:ro
        networks:
            - backend

    ### â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Publicâ€‘folder backups â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    backup:
        image: alpine:3.19
        restart: always
        environment:
            TZ: Europe/Berlin
        volumes:
            - public:/src:ro # readâ€‘only â€“ nothing can corrupt our uploads
            - auto-file-backups:/dest
            - /etc/timezone:/etc/timezone:ro
            - /etc/localtime:/etc/localtime:ro
        # tiny oneâ€‘liner: install zip + findutils, then loop forever
        command: >
            sh -c "apk add --no-cache zip findutils tzdata &&
                while true; do
                    TS=\$(date +'%Y-%m-%dT%H-%M-%S');
                    echo \"ğŸ“¦ Creating /dest/public-\$TS.zip\";
                    zip -rq /dest/public-\$TS.zip /src;
                    echo \"ğŸ§¹ Purging zips older than 10 daysâ€¦\";
                    find /dest -name 'public-*.zip' -mtime +10 -type f -print -delete;
                    echo \"ğŸ˜´ Sleeping 10hâ€¦\";
                    sleep 36000;
                done"

    ### â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ React SPA â”€â”€â”€â”€â”€â”€â”€â”€â”€
    web:
        build:
            context: ./react # contains Dockerfile.react
            args:
                ENV_FILE: .env.prod
        restart: always
        networks:
            - frontend
        environment:
            TZ: Europe/Berlin
        volumes:
            - /etc/timezone:/etc/timezone:ro
            - /etc/localtime:/etc/localtime:ro
        ports:
            - "3001:80"
        depends_on:
            api:
                condition: service_started

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Cache / PubSub â”€â”€â”€â”€â”€â”€â”€â”€
    redis:
        image: redis:7-alpine
        restart: always
        environment:
            TZ: Europe/Berlin
            REDIS_PASSWORD: ${REDIS_PASSWORD}
        command:
            [
                "redis-server",
                "--save",
                "60",
                "1",
                "--loglevel",
                "warning",
                "--requirepass",
                "${REDIS_PASSWORD}",
            ]
        networks:
            - backend
        volumes:
            - redis-data:/data
            - /etc/timezone:/etc/timezone:ro
            - /etc/localtime:/etc/localtime:ro
        healthcheck:
            test: ["CMD", "redis-cli", "-a", "${REDIS_PASSWORD}", "ping"]
            interval: 30s
            timeout: 10s
            retries: 5

volumes:
    mongo-data:
    rabbitmq-data:
    public:
    auto-file-backups:
    auto-db-backup:
    redis-data:
    tmp-files:

networks:
    backend:
        internal: true
    frontend:
        driver: bridge
